{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Artificial Neural Networks and Deep Learning - 2025/2","text":"<p>Rodrigo Paoliello de Medeiros</p>"},{"location":"#deliverables","title":"Deliverables","text":"<ul> <li> Data Exercise - 05/09</li> <li> Perceptron Exercise - 12/09</li> <li> MLP Exercise - 19/09</li> <li> Classification Project - 21/09</li> <li> Metrics Exercise - 17/10</li> <li> Regression Project - 19/10</li> <li> Generative Models Project - 16/11</li> </ul>"},{"location":"exercises/data/notebook/","title":"1. Data","text":"<p>First we will generate a synthetic dataset with a total of 400 samples, divided equally among 4 classes (100 samples each), using a Gaussian distribution based on the given means and standard deviations:</p> In\u00a0[99]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Set random seed for reproducibility\nnp.random.seed(42)\n\n# Define parameters for each class\nclass_params = {\n    0: {'mean': [2, 3], 'std': [0.8, 2.5]},\n    1: {'mean': [5, 6], 'std': [1.2, 1.9]},\n    2: {'mean': [8, 1], 'std': [0.9, 0.9]},\n    3: {'mean': [15, 4], 'std': [0.5, 2.0]}\n}\n\n# Generate the data\ndata = []\nlabels = []\n\n# Gaussian distributions for each class\nfor label, params in class_params.items():\n    points = np.random.normal(loc=params['mean'], scale=params['std'], size=(100, 2))\n    data.append(points)\n    labels.append(np.full(100, label))\n\n# Combine into arrays\ndata = np.vstack(data)\nlabels = np.hstack(labels)\n\nprint(\"Dataset generated: \", data.shape, labels.shape)\n</pre> import numpy as np import matplotlib.pyplot as plt  # Set random seed for reproducibility np.random.seed(42)  # Define parameters for each class class_params = {     0: {'mean': [2, 3], 'std': [0.8, 2.5]},     1: {'mean': [5, 6], 'std': [1.2, 1.9]},     2: {'mean': [8, 1], 'std': [0.9, 0.9]},     3: {'mean': [15, 4], 'std': [0.5, 2.0]} }  # Generate the data data = [] labels = []  # Gaussian distributions for each class for label, params in class_params.items():     points = np.random.normal(loc=params['mean'], scale=params['std'], size=(100, 2))     data.append(points)     labels.append(np.full(100, label))  # Combine into arrays data = np.vstack(data) labels = np.hstack(labels)  print(\"Dataset generated: \", data.shape, labels.shape) <pre>Dataset generated:  (400, 2) (400,)\n</pre> <p>We will now plot a 2D scatter plot showing all the data points, with a different color for each class:</p> In\u00a0[100]: Copied! <pre>plt.figure(figsize=(10, 7))\ncolors = ['red', 'blue', 'green', 'purple']\n\n# Plot each class with different colors\nfor i in range(4):\n    plt.scatter(\n        data[labels == i, 0],\n        data[labels == i, 1],\n        label=f'Class {i}',\n        color=colors[i],\n        alpha=0.7\n    )\n\nplt.xlabel('Feature 1')\nplt.ylabel('Feature 2')\nplt.title('Synthetic Dataset - 4 Classes')\nplt.legend()\nplt.grid(True)\nplt.show()\n</pre> plt.figure(figsize=(10, 7)) colors = ['red', 'blue', 'green', 'purple']  # Plot each class with different colors for i in range(4):     plt.scatter(         data[labels == i, 0],         data[labels == i, 1],         label=f'Class {i}',         color=colors[i],         alpha=0.7     )  plt.xlabel('Feature 1') plt.ylabel('Feature 2') plt.title('Synthetic Dataset - 4 Classes') plt.legend() plt.grid(True) plt.show() <p>The synthetic dataset forms four Gaussian clusters with distinct shapes and spreads. Class 0 is centered near (2, 3) with a wide vertical spread due to its larger variance in the y-direction, while Class 1 lies near (5, 6) with moderate spread in both axes. Class 2 is a compact, almost circular cluster at (8, 1), and Class 3 is tightly concentrated around x = 15 but elongated vertically. Class 3 is clearly isolated because of its much larger x-mean, while Classes 0, 1, and 2 occupy overlapping regions in the central space. Class 0 and Class 1 overlap in the higher y-region, and although Class 2 is generally separate, its boundary edges could touch Class 1 if variance increases.</p> <p>This arrangement shows that purely linear separation is not feasible: Class 3 could be split off by a vertical line, but Classes 0, 1, and 2 require non-linear boundaries. A neural network, such as an MLP with <code>tanh</code> activations, would likely learn curved, flexible decision regions: bending around Class 2, carving out Classes 0 and 1 in the upper region, and isolating Class 3 on the far right. The sketch below illustrates what such non-linear boundaries might look like:</p> <p></p> <p>We'll create a synthetic dataset with 500 samples for Class A and 500 samples for Class B, using a multivariate normal distribution with the parameters provided:</p> In\u00a0[101]: Copied! <pre># Parameters for Class A\nmean_A = np.array([0, 0, 0, 0, 0])\ncov_A = np.array([\n    [1.0, 0.8, 0.1, 0.0, 0.0],\n    [0.8, 1.0, 0.3, 0.0, 0.0],\n    [0.1, 0.3, 1.0, 0.5, 0.0],\n    [0.0, 0.0, 0.5, 1.0, 0.2],\n    [0.0, 0.0, 0.0, 0.2, 1.0]\n])\n\n# Parameters for Class B\nmean_B = np.array([1.5, 1.5, 1.5, 1.5, 1.5])\ncov_B = np.array([\n    [1.5, -0.7, 0.2, 0.0, 0.0],\n    [-0.7, 1.5, 0.4, 0.0, 0.0],\n    [0.2, 0.4, 1.5, 0.6, 0.0],\n    [0.0, 0.0, 0.6, 1.5, 0.3],\n    [0.0, 0.0, 0.0, 0.3, 1.5]\n])\n\n# Generate samples using multivariate normal distribution\nsamples_A = np.random.multivariate_normal(mean_A, cov_A, size=500)\nsamples_B = np.random.multivariate_normal(mean_B, cov_B, size=500)\n\n# Create labels\nlabels_A = np.zeros(500)  # Class A = 0\nlabels_B = np.ones(500)   # Class B = 1\n\n# Combine data\nX = np.vstack([samples_A, samples_B])\ny = np.hstack([labels_A, labels_B])\n\nprint(\"Dataset shape:\", X.shape)\nprint(\"Labels shape:\", y.shape)\n</pre> # Parameters for Class A mean_A = np.array([0, 0, 0, 0, 0]) cov_A = np.array([     [1.0, 0.8, 0.1, 0.0, 0.0],     [0.8, 1.0, 0.3, 0.0, 0.0],     [0.1, 0.3, 1.0, 0.5, 0.0],     [0.0, 0.0, 0.5, 1.0, 0.2],     [0.0, 0.0, 0.0, 0.2, 1.0] ])  # Parameters for Class B mean_B = np.array([1.5, 1.5, 1.5, 1.5, 1.5]) cov_B = np.array([     [1.5, -0.7, 0.2, 0.0, 0.0],     [-0.7, 1.5, 0.4, 0.0, 0.0],     [0.2, 0.4, 1.5, 0.6, 0.0],     [0.0, 0.0, 0.6, 1.5, 0.3],     [0.0, 0.0, 0.0, 0.3, 1.5] ])  # Generate samples using multivariate normal distribution samples_A = np.random.multivariate_normal(mean_A, cov_A, size=500) samples_B = np.random.multivariate_normal(mean_B, cov_B, size=500)  # Create labels labels_A = np.zeros(500)  # Class A = 0 labels_B = np.ones(500)   # Class B = 1  # Combine data X = np.vstack([samples_A, samples_B]) y = np.hstack([labels_A, labels_B])  print(\"Dataset shape:\", X.shape) print(\"Labels shape:\", y.shape) <pre>Dataset shape: (1000, 5)\nLabels shape: (1000,)\n</pre> <p>Since we cannot plot a 5D graph, we will use Principal Component Analysis (PCA) to project the 5D data down to 2 dimensions. Then we'll create a scatter plot of this 2D representation, with Class A represented by red points and Class B being represented as blue points:</p> In\u00a0[102]: Copied! <pre>from sklearn.decomposition import PCA\n\n# Apply PCA to reduce dimensions to 2D\npca = PCA(n_components=2)\nX_pca = pca.fit_transform(X)\n\n# Scatter plot\nplt.figure(figsize=(10, 7))\ncolors = ['red', 'blue']\nclasses = ['A', 'B']\nfor i, color in enumerate(colors):\n    plt.scatter(\n        X_pca[y == i, 0],\n        X_pca[y == i, 1],\n        label=f'Class {classes[i]}',\n        color=color,\n        alpha=0.7\n    )\nplt.xlabel('First Principal Component')\nplt.ylabel('Second Principal Component')\nplt.title('PCA Visualization of 5D Data')\nplt.legend()\nplt.grid()\nplt.show()\n</pre> from sklearn.decomposition import PCA  # Apply PCA to reduce dimensions to 2D pca = PCA(n_components=2) X_pca = pca.fit_transform(X)  # Scatter plot plt.figure(figsize=(10, 7)) colors = ['red', 'blue'] classes = ['A', 'B'] for i, color in enumerate(colors):     plt.scatter(         X_pca[y == i, 0],         X_pca[y == i, 1],         label=f'Class {classes[i]}',         color=color,         alpha=0.7     ) plt.xlabel('First Principal Component') plt.ylabel('Second Principal Component') plt.title('PCA Visualization of 5D Data') plt.legend() plt.grid() plt.show() <p>The PCA projection of the 5D dataset reveals that Classes A and B overlap substantially in two dimensions. Their centers are slightly offset, but the distributions largely intersect, and both classes display similar spread patterns. This means that in the reduced 2D space there are no clean visual boundaries to separate them.</p> <p>This overlap reflects the underlying challenge: the full 5D structure is governed by different covariance patterns in each class, producing relationships that are not well captured by straight lines. A simple linear classifier cannot resolve such intertwined regions, as any single hyperplane would misclassify a significant portion of the data. To achieve better separation, a more expressive model is needed. A multi-layer neural network with non-linear activation functions can transform the input space into higher-order representations, bending decision boundaries around the overlapping regions. Such non-linear models are better suited to capture the complex geometry of the dataset, making accurate classification feasible where linear methods fall short.</p> <p>First, we'll download the Spaceship Titanic dataset from Kaggle, especifically the <code>train.csv</code>, since we're only using this for preparation.</p> <p>The Spaceship Titanic dataset is a sci-fi reimagining of the classic Titanic survival prediction task. It is framed as a binary classification problem, where the target column <code>Transported</code> indicates whether a passenger was transported to another dimension (<code>True</code>) or remained in the original dimension (<code>False</code>) following the spaceship incident.</p> <p>The training file, <code>train.csv</code>, contains records for roughly two-thirds of the ~8,700 passengers. Each passenger is identified by a unique <code>PassengerId</code> that encodes group membership (<code>gggg_pp</code>, where <code>gggg</code> is the group and <code>pp</code> is the index within that group). Groups often represent families or traveling companions.</p> <p>The dataset provides a mix of demographic, behavioral, and voyage-related features:</p> <ul> <li>HomePlanet \u2014 Planet of origin (permanent residence).</li> <li>CryoSleep \u2014 Whether the passenger elected suspended animation for the voyage.</li> <li>Cabin \u2014 Passenger cabin in the format <code>deck/num/side</code>, where <code>side</code> is <code>P</code> (Port) or <code>S</code> (Starboard).</li> <li>Destination \u2014 Planet of debarkation.</li> <li>Age \u2014 Passenger\u2019s age in years.</li> <li>VIP \u2014 Whether the passenger paid for special VIP service.</li> <li>RoomService, FoodCourt, ShoppingMall, Spa, VRDeck \u2014 Expenditures at various luxury amenities onboard.</li> <li>Name \u2014 Passenger\u2019s full name (not directly predictive).</li> <li>Transported \u2014 Target variable: <code>True</code> if transported to another dimension, <code>False</code> otherwise.</li> </ul> <p>Together, these variables form a rich dataset combining categorical, numerical, and textual features. The challenge lies in preprocessing and modeling these attributes effectively to predict the outcome <code>Transported</code>. The task is analogous to Titanic survival prediction but recast in a futuristic setting.</p> In\u00a0[103]: Copied! <pre>import pandas as pd\n\ndf = pd.read_csv(\"spaceship-titanic/train.csv\")\n\ndf.head(5)\n</pre> import pandas as pd  df = pd.read_csv(\"spaceship-titanic/train.csv\")  df.head(5) Out[103]: PassengerId HomePlanet CryoSleep Cabin Destination Age VIP RoomService FoodCourt ShoppingMall Spa VRDeck Name Transported 0 0001_01 Europa False B/0/P TRAPPIST-1e 39.0 False 0.0 0.0 0.0 0.0 0.0 Maham Ofracculy False 1 0002_01 Earth False F/0/S TRAPPIST-1e 24.0 False 109.0 9.0 25.0 549.0 44.0 Juanna Vines True 2 0003_01 Europa False A/0/S TRAPPIST-1e 58.0 True 43.0 3576.0 0.0 6715.0 49.0 Altark Susent False 3 0003_02 Europa False A/0/S TRAPPIST-1e 33.0 False 0.0 1283.0 371.0 3329.0 193.0 Solam Susent False 4 0004_01 Earth False F/1/S TRAPPIST-1e 16.0 False 303.0 70.0 151.0 565.0 2.0 Willy Santantines True <p>Let's list all the numerical and categorical features of this dataset:</p> In\u00a0[104]: Copied! <pre># Separate features and target\ntarget_column = 'Transported'\ny = df[target_column].astype(int)\nX = df.drop(columns=[target_column])\n\n# Identify numerical and categorical features\nnumerical_features = X.select_dtypes(include=['number']).columns.tolist()\ncategorical_features = X.select_dtypes(include=['object', 'category', 'bool']).columns.tolist()\n\nprint(\"\\nNumerical Features:\")\nfor feature in numerical_features:\n    print(f\"- {feature}\")\n\nprint(\"\\nCategorical Features:\")\nfor feature in categorical_features:\n    print(f\"- {feature}\")\n</pre> # Separate features and target target_column = 'Transported' y = df[target_column].astype(int) X = df.drop(columns=[target_column])  # Identify numerical and categorical features numerical_features = X.select_dtypes(include=['number']).columns.tolist() categorical_features = X.select_dtypes(include=['object', 'category', 'bool']).columns.tolist()  print(\"\\nNumerical Features:\") for feature in numerical_features:     print(f\"- {feature}\")  print(\"\\nCategorical Features:\") for feature in categorical_features:     print(f\"- {feature}\") <pre>\nNumerical Features:\n- Age\n- RoomService\n- FoodCourt\n- ShoppingMall\n- Spa\n- VRDeck\n\nCategorical Features:\n- PassengerId\n- HomePlanet\n- CryoSleep\n- Cabin\n- Destination\n- VIP\n- Name\n</pre> <p>We'll now investigate the dataset for missing values:</p> In\u00a0[105]: Copied! <pre># Count missing values\nmissing_counts = df.isna().sum()\nn_rows = len(df)\n\n# Create a table for missing values\nmissing_table = (\n    pd.DataFrame({\n        \"missing_count\": missing_counts,\n        \"missing_pct\": (missing_counts / n_rows * 100).round(2)\n    })\n    .query(\"missing_count &gt; 0\")\n    .sort_values(\"missing_count\", ascending=False)\n)\n\nprint(\"\\nMissing Values\")\nprint(missing_table.to_string(float_format=lambda x: f\"{x:,.2f}%\"))\n</pre> # Count missing values missing_counts = df.isna().sum() n_rows = len(df)  # Create a table for missing values missing_table = (     pd.DataFrame({         \"missing_count\": missing_counts,         \"missing_pct\": (missing_counts / n_rows * 100).round(2)     })     .query(\"missing_count &gt; 0\")     .sort_values(\"missing_count\", ascending=False) )  print(\"\\nMissing Values\") print(missing_table.to_string(float_format=lambda x: f\"{x:,.2f}%\")) <pre>\nMissing Values\n              missing_count  missing_pct\nCryoSleep               217        2.50%\nShoppingMall            208        2.39%\nVIP                     203        2.34%\nHomePlanet              201        2.31%\nName                    200        2.30%\nCabin                   199        2.29%\nVRDeck                  188        2.16%\nFoodCourt               183        2.11%\nSpa                     183        2.11%\nDestination             182        2.09%\nRoomService             181        2.08%\nAge                     179        2.06%\n</pre> <p>We will now clean and transform the data so it can be fed into a neural network. The <code>tanh</code> activation function produces outputs in the range <code>[-1, 1]</code>, so the input data should be scaled appropriately for stable training.</p> <p>First we'll implement a strategy to handle the missing values in all the affected columns:</p> <ul> <li><p>Numerical Features (Age, RoomService, FoodCourt, ShoppingMall, Spa, VRDeck): Use median imputation. Median is robust against outliers (e.g., some passengers spend huge amounts in VRDeck or FoodCourt).</p> </li> <li><p>Categorical Features (HomePlanet, Destination, Cabin): Use most frequent (mode) imputation. This fills missing entries with the most common value, which preserves the categorical distribution. Drop PassengerId and Name as they are identifiers.</p> </li> <li><p>Boolean Features (CryoSleep, VIP): Treat them as categorical and impute with most frequent value. This avoids introducing bias since only ~2% are missing.</p> </li> </ul> In\u00a0[106]: Copied! <pre>from sklearn.impute import SimpleImputer\n\n# Define the columns we will actually use downstream\nnumerical_features = ['Age', 'RoomService', 'FoodCourt', 'ShoppingMall', 'Spa', 'VRDeck']\ncategorical_features = ['HomePlanet', 'Destination', 'Cabin', 'CryoSleep', 'VIP']\n\n# Drop identifier columns from features\nid_cols = ['PassengerId', 'Name']\nX = df.drop(columns=[target_column] + id_cols, errors='ignore').copy()\n\n# Create imputers\nnum_imputer = SimpleImputer(strategy=\"median\")          # robust to outliers in numericals\ncat_imputer = SimpleImputer(strategy=\"most_frequent\")   # preserves mode for categoricals/booleans\n\n# Apply the imputers\nX[numerical_features] = num_imputer.fit_transform(X[numerical_features])\nX[categorical_features] = cat_imputer.fit_transform(X[categorical_features])\n\n# Sanity check: no missing values should remain in these groups\nprint(\"Remaining NAs (numeric):\", int(X[numerical_features].isna().sum().sum()))\nprint(\"Remaining NAs (categorical):\", int(X[categorical_features].isna().sum().sum()))\n</pre> from sklearn.impute import SimpleImputer  # Define the columns we will actually use downstream numerical_features = ['Age', 'RoomService', 'FoodCourt', 'ShoppingMall', 'Spa', 'VRDeck'] categorical_features = ['HomePlanet', 'Destination', 'Cabin', 'CryoSleep', 'VIP']  # Drop identifier columns from features id_cols = ['PassengerId', 'Name'] X = df.drop(columns=[target_column] + id_cols, errors='ignore').copy()  # Create imputers num_imputer = SimpleImputer(strategy=\"median\")          # robust to outliers in numericals cat_imputer = SimpleImputer(strategy=\"most_frequent\")   # preserves mode for categoricals/booleans  # Apply the imputers X[numerical_features] = num_imputer.fit_transform(X[numerical_features]) X[categorical_features] = cat_imputer.fit_transform(X[categorical_features])  # Sanity check: no missing values should remain in these groups print(\"Remaining NAs (numeric):\", int(X[numerical_features].isna().sum().sum())) print(\"Remaining NAs (categorical):\", int(X[categorical_features].isna().sum().sum())) <pre>Remaining NAs (numeric): 0\nRemaining NAs (categorical): 0\n</pre> <p>Now, we'll encode categorical features into a numerical format using one-hot encoding with <code>pd.get_dummies()</code>, which creates binary columns for each category:</p> In\u00a0[107]: Copied! <pre># One-hot encode categorical features\nX_encoded = pd.get_dummies(X, columns=categorical_features, drop_first=True)\nprint(\"Encoded shape:\", X_encoded.shape)\n</pre> # One-hot encode categorical features X_encoded = pd.get_dummies(X, columns=categorical_features, drop_first=True) print(\"Encoded shape:\", X_encoded.shape) <pre>Encoded shape: (8693, 6571)\n</pre> <p>We will now scale the numerical variables. Because the <code>tanh</code> activation function is centered at zero and outputs values in the range [-1, 1], bringing inputs onto a similar scale is essential. Scaling prevents features with large ranges from dominating learning, stabilizes gradient updates, and accelerates convergence.</p> <p>Here we normalize values to [-1, 1], aligning the inputs with the activation\u2019s range. This practice improves training efficiency and helps the network learn more reliable non-linear decision boundaries.</p> In\u00a0[108]: Copied! <pre>from sklearn.preprocessing import MinMaxScaler\n\n# Scale numerical features in the encoded/imputed feature matrix\nscaler = MinMaxScaler(feature_range=(-1, 1))\nX_scaled = X_encoded.copy()\nX_scaled[numerical_features] = scaler.fit_transform(X_scaled[numerical_features])\n\n# Quick preview\nprint(X_scaled[numerical_features].head())\n</pre> from sklearn.preprocessing import MinMaxScaler  # Scale numerical features in the encoded/imputed feature matrix scaler = MinMaxScaler(feature_range=(-1, 1)) X_scaled = X_encoded.copy() X_scaled[numerical_features] = scaler.fit_transform(X_scaled[numerical_features])  # Quick preview print(X_scaled[numerical_features].head()) <pre>        Age  RoomService  FoodCourt  ShoppingMall       Spa    VRDeck\n0 -0.012658    -1.000000  -1.000000     -1.000000 -1.000000 -1.000000\n1 -0.392405    -0.984784  -0.999396     -0.997872 -0.951000 -0.996354\n2  0.468354    -0.993997  -0.760105     -1.000000 -0.400660 -0.995939\n3 -0.164557    -1.000000  -0.913930     -0.968415 -0.702874 -0.984005\n4 -0.594937    -0.957702  -0.995304     -0.987145 -0.949572 -0.999834\n</pre> <p>We'll now create histograms for <code>FoodCourt</code> and <code>Age</code> before and after scaling to show the difference, the values should be between [-1, 1] instead of their original values, following the same distribution:</p> In\u00a0[109]: Copied! <pre>import matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(2, 1, figsize=(16, 10))\n\n# FoodCourt before\ndf['FoodCourt'].dropna().hist(bins=30, ax=axes[0])\naxes[0].set_title('FoodCourt \u2014 Before Scaling')\n\n# FoodCourt after\nX_scaled['FoodCourt'].dropna().hist(bins=30, ax=axes[1])\naxes[1].set_title('FoodCourt \u2014 After Scaling ([-1, 1])')\n\nplt.show()\n\nfig, axes = plt.subplots(2, 1, figsize=(16, 10))\n\n# Age before\ndf['Age'].dropna().hist(bins=30, ax=axes[0])\naxes[0].set_title('Age \u2014 Before Scaling')\n\n# Age after\nX_scaled['Age'].dropna().hist(bins=30, ax=axes[1])\naxes[1].set_title('Age \u2014 After Scaling ([-1, 1])')\n\nplt.show()\n</pre> import matplotlib.pyplot as plt  fig, axes = plt.subplots(2, 1, figsize=(16, 10))  # FoodCourt before df['FoodCourt'].dropna().hist(bins=30, ax=axes[0]) axes[0].set_title('FoodCourt \u2014 Before Scaling')  # FoodCourt after X_scaled['FoodCourt'].dropna().hist(bins=30, ax=axes[1]) axes[1].set_title('FoodCourt \u2014 After Scaling ([-1, 1])')  plt.show()  fig, axes = plt.subplots(2, 1, figsize=(16, 10))  # Age before df['Age'].dropna().hist(bins=30, ax=axes[0]) axes[0].set_title('Age \u2014 Before Scaling')  # Age after X_scaled['Age'].dropna().hist(bins=30, ax=axes[1]) axes[1].set_title('Age \u2014 After Scaling ([-1, 1])')  plt.show()"},{"location":"exercises/data/notebook/#data","title":"Data\u00b6","text":""},{"location":"exercises/data/notebook/#exercise-1-exploring-class-separability","title":"Exercise 1 - Exploring Class Separability\u00b6","text":""},{"location":"exercises/data/notebook/#generate-the-data","title":"Generate the Data\u00b6","text":""},{"location":"exercises/data/notebook/#plot-the-data","title":"Plot the Data\u00b6","text":""},{"location":"exercises/data/notebook/#exercise-2-non-linearity-in-higher-dimensions","title":"Exercise 2 - Non-Linearity in Higher Dimensions\u00b6","text":""},{"location":"exercises/data/notebook/#generate-the-data","title":"Generate the Data\u00b6","text":""},{"location":"exercises/data/notebook/#visualize-the-data","title":"Visualize the Data\u00b6","text":""},{"location":"exercises/data/notebook/#analyze-the-plot","title":"Analyze the Plot\u00b6","text":""},{"location":"exercises/data/notebook/#exercise-3-preparing-real-world-data-for-a-neural-network","title":"Exercise 3 - Preparing Real-World Data for a Neural Network\u00b6","text":""},{"location":"exercises/data/notebook/#get-the-data","title":"Get the Data\u00b6","text":""},{"location":"exercises/data/notebook/#describe-the-data","title":"Describe the Data\u00b6","text":""},{"location":"exercises/data/notebook/#preprocess-the-data","title":"Preprocess the Data\u00b6","text":""},{"location":"exercises/data/notebook/#visualize-the-results","title":"Visualize the Results\u00b6","text":""},{"location":"exercises/data/notebook/#ai-assistance","title":"AI Assistance\u00b6","text":"<p>I used AI (ChatGPT) to help with:</p> <ul> <li>Reviewing my code and outputs for clarity.</li> <li>Suggesting improvements to formatting and readability.</li> </ul> <p>All code was executed, tested, and validated locally by me. Nothing was done with AI that I didn't understand.</p>"},{"location":"exercises/perceptron/notebook/","title":"2. Perceptron","text":"<p>For this exercise, we will implement a simple Perceptron model from scratch using only NumPy for basic linear algebra operations. Below is the perceptron class, along with functions to visualize the decision boundary and accuracy over epochs.</p> In\u00a0[24]: Copied! <pre>import numpy as np\nimport matplotlib.pyplot as plt\n\n# Random seed for reproducibility\nnp.random.seed(24)\n\n# Perceptron Implementation\nclass Perceptron:\n    def __init__(self, input_dim=2, learning_rate=0.01, max_epochs=100):\n        self.w = np.zeros(input_dim)   # weights\n        self.b = 0.0                   # bias\n        self.lr = learning_rate\n        self.max_epochs = max_epochs\n        self.accuracy_history = []\n\n    # Prediction function\n    def predict(self, X):\n        linear_output = np.dot(X, self.w) + self.b\n        return np.where(linear_output &gt;= 0, 1, -1)\n\n    # Training function\n    def fit(self, X, y):\n        for epoch in range(self.max_epochs):\n            errors = 0\n            for xi, target in zip(X, y):\n                pred = self.predict(xi)\n                if pred != target: # Misclassification\n                    update = self.lr * target\n                    self.w += update * xi\n                    self.b += update\n                    errors += 1\n            acc = self.evaluate(X, y)\n            self.accuracy_history.append(acc)\n            if errors == 0:\n                break\n    \n    # Evaluation function\n    def evaluate(self, X, y):\n        predictions = self.predict(X)\n        return np.mean(predictions == y)\n\n# Utility functions\ndef plot_data(X, y, title=\"Data Distribution\"):\n    plt.figure(figsize=(6,6))\n    plt.scatter(X[y==1,0], X[y==1,1], color=\"red\", label=\"Class 0\", alpha=0.6)\n    plt.scatter(X[y==-1,0], X[y==-1,1], color=\"blue\", label=\"Class 1\", alpha=0.6)\n    plt.legend()\n    plt.title(title)\n    plt.xlabel(\"X1\")\n    plt.ylabel(\"X2\")\n    plt.grid(True)\n    plt.show()\n\n# Decision boundary plotting\ndef plot_decision_boundary(model, X, y, title=\"Decision Boundary\"):\n    plt.figure(figsize=(6,6))\n    plt.scatter(X[y==1,0], X[y==1,1], color=\"red\", label=\"Class 0\", alpha=0.6)\n    plt.scatter(X[y==-1,0], X[y==-1,1], color=\"blue\", label=\"Class 1\", alpha=0.6)\n\n    # Decision boundary\n    x_min, x_max = X[:,0].min()-1, X[:,0].max()+1\n    y_min, y_max = X[:,1].min()-1, X[:,1].max()+1\n    xx = np.linspace(x_min, x_max, 200)\n    if model.w[1] != 0: \n        yy = -(model.w[0] * xx + model.b) / model.w[1]\n        plt.plot(xx, yy, \"k--\", label=\"Decision boundary\")\n\n    # Highlight misclassified\n    preds = model.predict(X)\n    misclassified = X[preds != y]\n    if len(misclassified) &gt; 0:\n        plt.scatter(misclassified[:,0], misclassified[:,1], \n                    facecolors='none', edgecolors='yellow', s=80, label=\"Misclassified\")\n\n    plt.legend()\n    plt.title(title)\n    plt.xlabel(\"X1\")\n    plt.ylabel(\"X2\")\n    plt.grid(True)\n    plt.show()\n\n# Accuracy over epochs plotting\ndef plot_accuracy(history, title=\"Accuracy over Epochs\"):\n    plt.figure()\n    plt.plot(range(1, len(history)+1), history, marker=\"o\")\n    plt.title(title)\n    plt.xlabel(\"Epoch\")\n    plt.ylabel(\"Accuracy\")\n    plt.grid(True)\n    plt.show()\n</pre> import numpy as np import matplotlib.pyplot as plt  # Random seed for reproducibility np.random.seed(24)  # Perceptron Implementation class Perceptron:     def __init__(self, input_dim=2, learning_rate=0.01, max_epochs=100):         self.w = np.zeros(input_dim)   # weights         self.b = 0.0                   # bias         self.lr = learning_rate         self.max_epochs = max_epochs         self.accuracy_history = []      # Prediction function     def predict(self, X):         linear_output = np.dot(X, self.w) + self.b         return np.where(linear_output &gt;= 0, 1, -1)      # Training function     def fit(self, X, y):         for epoch in range(self.max_epochs):             errors = 0             for xi, target in zip(X, y):                 pred = self.predict(xi)                 if pred != target: # Misclassification                     update = self.lr * target                     self.w += update * xi                     self.b += update                     errors += 1             acc = self.evaluate(X, y)             self.accuracy_history.append(acc)             if errors == 0:                 break          # Evaluation function     def evaluate(self, X, y):         predictions = self.predict(X)         return np.mean(predictions == y)  # Utility functions def plot_data(X, y, title=\"Data Distribution\"):     plt.figure(figsize=(6,6))     plt.scatter(X[y==1,0], X[y==1,1], color=\"red\", label=\"Class 0\", alpha=0.6)     plt.scatter(X[y==-1,0], X[y==-1,1], color=\"blue\", label=\"Class 1\", alpha=0.6)     plt.legend()     plt.title(title)     plt.xlabel(\"X1\")     plt.ylabel(\"X2\")     plt.grid(True)     plt.show()  # Decision boundary plotting def plot_decision_boundary(model, X, y, title=\"Decision Boundary\"):     plt.figure(figsize=(6,6))     plt.scatter(X[y==1,0], X[y==1,1], color=\"red\", label=\"Class 0\", alpha=0.6)     plt.scatter(X[y==-1,0], X[y==-1,1], color=\"blue\", label=\"Class 1\", alpha=0.6)      # Decision boundary     x_min, x_max = X[:,0].min()-1, X[:,0].max()+1     y_min, y_max = X[:,1].min()-1, X[:,1].max()+1     xx = np.linspace(x_min, x_max, 200)     if model.w[1] != 0:          yy = -(model.w[0] * xx + model.b) / model.w[1]         plt.plot(xx, yy, \"k--\", label=\"Decision boundary\")      # Highlight misclassified     preds = model.predict(X)     misclassified = X[preds != y]     if len(misclassified) &gt; 0:         plt.scatter(misclassified[:,0], misclassified[:,1],                      facecolors='none', edgecolors='yellow', s=80, label=\"Misclassified\")      plt.legend()     plt.title(title)     plt.xlabel(\"X1\")     plt.ylabel(\"X2\")     plt.grid(True)     plt.show()  # Accuracy over epochs plotting def plot_accuracy(history, title=\"Accuracy over Epochs\"):     plt.figure()     plt.plot(range(1, len(history)+1), history, marker=\"o\")     plt.title(title)     plt.xlabel(\"Epoch\")     plt.ylabel(\"Accuracy\")     plt.grid(True)     plt.show() <p>First we're going to generate two classes of 2D data points (1000 samples per class) using multivariate normal distributions with the parameters that were given:</p> In\u00a0[25]: Copied! <pre># Parameters for linearly separable data\nmean0, cov0 = [1.5, 1.5], [[0.5, 0], [0, 0.5]]\nmean1, cov1 = [5, 5], [[0.5, 0], [0, 0.5]]\n\n# Generate linearly separable data\nclass0 = np.random.multivariate_normal(mean0, cov0, 1000)\nclass1 = np.random.multivariate_normal(mean1, cov1, 1000)\n\n# Combine into dataset\nX1 = np.vstack((class0, class1))\ny1 = np.hstack((-1*np.ones(1000), np.ones(1000)))\n\nplot_data(X1, y1, \"Linearly Separable Data\")\n</pre> # Parameters for linearly separable data mean0, cov0 = [1.5, 1.5], [[0.5, 0], [0, 0.5]] mean1, cov1 = [5, 5], [[0.5, 0], [0, 0.5]]  # Generate linearly separable data class0 = np.random.multivariate_normal(mean0, cov0, 1000) class1 = np.random.multivariate_normal(mean1, cov1, 1000)  # Combine into dataset X1 = np.vstack((class0, class1)) y1 = np.hstack((-1*np.ones(1000), np.ones(1000)))  plot_data(X1, y1, \"Linearly Separable Data\") <p>Now, we're going to implement a single-layer perceptron from scratch to classify the generated data into the two classes, using NumPy only for basic linear algebra operations.</p> In\u00a0[26]: Copied! <pre># Train Perceptron\nperc1 = Perceptron(input_dim=2, learning_rate=0.01, max_epochs=100)\nperc1.fit(X1, y1)\n\nprint(\"Final weights:\", perc1.w)\nprint(\"Final bias:\", perc1.b)\nprint(\"Final accuracy:\", perc1.evaluate(X1, y1))\n\nplot_decision_boundary(perc1, X1, y1, \"Decision Boundary\")\nplot_accuracy(perc1.accuracy_history, \"Accuracy over Epochs\")\n</pre> # Train Perceptron perc1 = Perceptron(input_dim=2, learning_rate=0.01, max_epochs=100) perc1.fit(X1, y1)  print(\"Final weights:\", perc1.w) print(\"Final bias:\", perc1.b) print(\"Final accuracy:\", perc1.evaluate(X1, y1))  plot_decision_boundary(perc1, X1, y1, \"Decision Boundary\") plot_accuracy(perc1.accuracy_history, \"Accuracy over Epochs\") <pre>Final weights: [0.02109579 0.03614885]\nFinal bias: -0.20000000000000004\nFinal accuracy: 1.0\n</pre> <p>The data's separability leads to quick convergence because the two clusters are centered far apart with little overlap, which means a straight line can perfectly separate them. In such a situation, the perceptron learning rule rapidly adjusts the weights after only a few misclassifications, since each update moves the decision boundary closer to an exact separator. Once all points fall on the correct side, no more updates are needed, and the algorithm converges in very few epochs. This clean separation also explains why the model achieves 100% accuracy rather than oscillating or plateauing below it.</p> <p>Now, we'll generate two new classes of 2D data points (1000 samples per class) using multivariate normal distributions with the parameters that were given, which will create partial overlap between the classes:</p> In\u00a0[27]: Copied! <pre>np.random.seed(24)\n# Parameters for overlapping data\nmean0, cov0 = [3, 3], [[1.5, 0], [0, 1.5]]\nmean1, cov1 = [4, 4], [[1.5, 0], [0, 1.5]]\n\n# Generate overlapping data\nclass0 = np.random.multivariate_normal(mean0, cov0, 1000)\nclass1 = np.random.multivariate_normal(mean1, cov1, 1000)\n\n# Combine into dataset\nX2 = np.vstack((class0, class1))\ny2 = np.hstack((-1*np.ones(1000), np.ones(1000)))\n\nplot_data(X2, y2, \"Exercise 2: Overlapping Data\")\n</pre> np.random.seed(24) # Parameters for overlapping data mean0, cov0 = [3, 3], [[1.5, 0], [0, 1.5]] mean1, cov1 = [4, 4], [[1.5, 0], [0, 1.5]]  # Generate overlapping data class0 = np.random.multivariate_normal(mean0, cov0, 1000) class1 = np.random.multivariate_normal(mean1, cov1, 1000)  # Combine into dataset X2 = np.vstack((class0, class1)) y2 = np.hstack((-1*np.ones(1000), np.ones(1000)))  plot_data(X2, y2, \"Exercise 2: Overlapping Data\") In\u00a0[28]: Copied! <pre>n_runs = 5\nresults = []\n\nfor i in range(n_runs):\n    # Reinitialize and train a new perceptron each run\n    perc = Perceptron(input_dim=2, learning_rate=0.01, max_epochs=100)\n    perc.fit(X2, y2)\n    \n    final_acc = perc.evaluate(X2, y2)\n    \n    results.append((perc, final_acc))\n\n# Select best run by highest final accuracy\nbest_run = max(results, key=lambda x: x[1])\nbest_perc, best_final_acc = best_run\n\nprint(\"Best Run:\")\nprint(\"Final weights:\", best_perc.w)\nprint(\"Final bias:\", best_perc.b)\nprint(f\"Final accuracy: {best_final_acc:.2f}\")\n\n# Plot decision boundary for best run\nplot_decision_boundary(best_perc, X2, y2, \"Decision Boundary (Best Run)\")\n\n# Plot accuracy history for best run\nplot_accuracy(best_perc.accuracy_history, \"Accuracy over Epochs (Best Run)\")\n</pre> n_runs = 5 results = []  for i in range(n_runs):     # Reinitialize and train a new perceptron each run     perc = Perceptron(input_dim=2, learning_rate=0.01, max_epochs=100)     perc.fit(X2, y2)          final_acc = perc.evaluate(X2, y2)          results.append((perc, final_acc))  # Select best run by highest final accuracy best_run = max(results, key=lambda x: x[1]) best_perc, best_final_acc = best_run  print(\"Best Run:\") print(\"Final weights:\", best_perc.w) print(\"Final bias:\", best_perc.b) print(f\"Final accuracy: {best_final_acc:.2f}\")  # Plot decision boundary for best run plot_decision_boundary(best_perc, X2, y2, \"Decision Boundary (Best Run)\")  # Plot accuracy history for best run plot_accuracy(best_perc.accuracy_history, \"Accuracy over Epochs (Best Run)\") <pre>Best Run:\nFinal weights: [0.06944049 0.09727756]\nFinal bias: -0.20000000000000004\nFinal accuracy: 0.51\n</pre> <p>With overlap, the perceptron cannot find a perfect linear separator. Unlike in Exercise 1 (linearly separable data), convergence never occurs, accuracy stays a little over 50%, and many points remain misclassified. The algorithm keeps updating because correcting one side causes errors on the other, this demonstrates the perceptron\u2019s limitation: it only guarantees convergence when the data is linearly separable.</p>"},{"location":"exercises/perceptron/notebook/#perceptron","title":"Perceptron\u00b6","text":""},{"location":"exercises/perceptron/notebook/#exercise-1","title":"Exercise 1\u00b6","text":""},{"location":"exercises/perceptron/notebook/#data-generation-task","title":"Data Generation Task\u00b6","text":""},{"location":"exercises/perceptron/notebook/#perceptron-implementation-task","title":"Perceptron Implementation Task\u00b6","text":""},{"location":"exercises/perceptron/notebook/#exercise-2","title":"Exercise 2\u00b6","text":""},{"location":"exercises/perceptron/notebook/#data-generation-task","title":"Data Generation Task\u00b6","text":""},{"location":"exercises/perceptron/notebook/#perceptron-implementation-task","title":"Perceptron Implementation Task\u00b6","text":""},{"location":"exercises/perceptron/notebook/#ai-assistance","title":"AI Assistance\u00b6","text":"<p>I used AI (ChatGPT) to help with:</p> <ul> <li>Reviewing my code and outputs for clarity.</li> <li>Suggesting improvements to formatting and readability.</li> </ul> <p>All code was executed, tested, and validated locally by me. Nothing was done with AI that I didn't understand.</p>"}]}